<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ターン制RPGゲーム</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a202c; /* Dark background */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            color: #e2e8f0; /* Light text color */
        }
        #game-container {
            display: flex;
            flex-direction: column;
            background-color: #2d3748; /* Slightly lighter dark background */
            border-radius: 16px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
            padding: 24px;
            gap: 20px;
            max-width: 600px; /* Max width for combined content */
            width: 95%; /* Responsive width */
            box-sizing: border-box;
        }
        #main-content-area { /* New wrapper for left and right sections */
            display: flex;
            flex-direction: row;
            gap: 20px;
            justify-content: center;
            align-items: flex-start;
            flex-wrap: wrap; /* Allow wrapping on smaller screens */
        }
        #left-column { /* New container for canvas and boss HP */
            display: flex;
            flex-direction: column;
            gap: 5px; /* Gap between canvas and boss HP */
            flex-grow: 1; /* Allow left section to grow */
            min-width: 300px; /* Minimum width for canvas */
            max-width: 374px; /* Max width for 11x11 field with TILE_SIZE=34 */
        }
        #canvas-wrapper {
            position: relative;
            border: 2px solid #4a5568; /* Darker gray border */
            border-radius: 8px;
            overflow: hidden;
            background-color: #1a202c; /* Very dark background for field */
            aspect-ratio: 1 / 1; /* Keep aspect ratio */
            display: flex; /* Center canvas content */
            justify-content: center;
            align-items: center;
            width: 100%; /* Take full width of its parent */
        }
        canvas {
            display: block;
            background-color: #1a202c; /* Very dark background for field */
        }
        #right-control-panel { /* Container for player HP, attacks, directions */
            display: flex;
            flex-direction: column;
            gap: 16px;
            align-items: center;
            flex-shrink: 0; /* Prevent shrinking on larger screens */
            width: 200px; /* Fixed width for control panel */
        }
        .direction-buttons, .attack-buttons {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        .direction-buttons {
            align-items: center;
        }
        .direction-buttons div {
            display: flex;
            gap: 8px;
        }
        .game-button {
            background-color: #4299e1; /* Blue */
            color: white;
            padding: 6px 10px;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.1s;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
            border: none;
        }
        .game-button:hover:not(:disabled) {
            background-color: #3182ce; /* Darker blue */
            transform: translateY(-2px);
        }
        .game-button:active:not(:disabled) {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        .game-button:disabled {
            background-color: #4a5568; /* Darker gray for disabled */
            color: #a0aec0; /* Lighter gray text for disabled */
            cursor: not-allowed;
            box-shadow: none;
        }
        .attack-button {
            padding: 8px 12px;
            font-size: 0.9rem;
            display: flex;
            flex-direction: row;
            align-items: center;
            justify-content: space-between;
            text-align: left;
            line-height: 1.2;
        }
        .attack-button.active {
            border: 3px solid #f6e05e; /* Yellow border for active */
            box-shadow: 0 0 15px rgba(246, 224, 94, 0.7);
        }
        #red-attack { background-color: #c53030; } /* Darker Red */
        #red-attack.active { border-color: #f6e05e; }
        #yellow-attack { background-color: #d69e2e; } /* Darker Orange */
        #yellow-attack.active { border-color: #f6e05e; }
        #blue-attack { background-color: #2b6cb0; } /* Darker Blue */
        #blue-attack.active { border-color: #f6e05e; }

        .hp-display, .energy-display {
            font-size: 0.5rem;
            font-weight: bold;
            color: #e2e8f0;
        }
        .hp-bar-container {
            width: 100%;
            background-color: #4a5568;
            border-radius: 4px;
            height: 6px;
            overflow: hidden;
        }
        .hp-bar {
            height: 100%;
            background-color: #ef4444;
            border-radius: 4px;
            transition: width 0.3s ease-out;
        }
        .energy-bar-container {
            width: 100%;
            background-color: #4a5568;
            border-radius: 4px;
            height: 4px;
            overflow: hidden;
            margin-top: 2px;
        }
        .energy-bar {
            height: 100%;
            background-color: #48bb78;
            border-radius: 4px;
            transition: width 0.3s ease-out;
        }

        #reset-button {
            background-color: #9b2c2c;
            margin-top: 20px;
            padding: 10px 20px;
        }
        #reset-button:hover:not(:disabled) {
            background-color: #7b1e1e;
        }

        #game-over-panel {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.85);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            visibility: hidden;
            opacity: 0;
            transition: visibility 0s, opacity 0.3s ease-in-out;
        }
        #game-over-panel.active {
            visibility: visible;
            opacity: 1;
        }
        .panel-content {
            background-color: #2d3748;
            padding: 30px;
            border-radius: 16px;
            text-align: center;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.4);
            transform: scale(0.9);
            transition: transform 0.3s ease-out;
            color: #e2e8f0;
        }
        #game-over-panel.active .panel-content {
            transform: scale(1);
        }
        .panel-content h2 {
            font-size: 2rem;
            margin-bottom: 15px;
            color: #e2e8f0;
        }
        .panel-content button {
            background-color: #4299e1;
            color: white;
            padding: 12px 25px;
            border-radius: 10px;
            font-size: 1rem;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.1s;
            border: none;
        }
        .panel-content button:hover {
            background-color: #3182ce;
            transform: translateY(-2px);
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            #main-content-area {
                flex-direction: column;
                align-items: center;
            }
            #left-column, #right-control-panel {
                width: 100%; /* Full width on smaller screens */
                max-width: 374px; /* Ensure canvas doesn't stretch too wide on small screens */
            }
            .direction-buttons, .attack-buttons {
                flex-direction: row; /* Horizontal on smaller screens */
                flex-wrap: wrap;
                justify-content: center;
            }
            .attack-button {
                flex: 1 1 auto;
                min-width: 80px;
                height: 60px;
            }
            .attack-button span.text-3xl {
                font-size: 2.5rem;
            }
            #game-container {
                padding: 12px;
            }
        }
    </style>
</head>
<body>
    <div id="game-container" class="flex flex-col items-center">
        <h1 class="text-xl font-bold text-gray-300 text-center" style="margin-bottom: 2px;">ターン制RPGゲーム</h1>

        <div id="main-content-area">
            <div id="left-column">
                <div id="canvas-wrapper">
                    <canvas id="gameCanvas"></canvas>
                </div>

                <div class="boss-hp-panel flex flex-col items-start w-full" style="margin-bottom: 1px;">
                    <span class="hp-display" style="margin-bottom: 2px;">ボスHP: <span id="boss-hp-value"></span></span>
                    <div class="hp-bar-container w-full" style="margin-top: 1px;">
                        <div id="boss-hp-bar" class="hp-bar"></div>
                    </div>
                </div>
            </div>

            <div id="right-control-panel">
                <div class="player-hp-panel flex flex-col items-center w-full" style="margin-bottom: 1px;">
                    <span class="hp-display" style="margin-bottom: 2px;">プレイヤーHP: <span id="player-hp-value"></span></span>
                    <div class="hp-bar-container w-full" style="margin-top: 1px;">
                        <div id="player-hp-bar" class="hp-bar"></div>
                    </div>
                </div>

                <div class="attack-buttons w-full">
                    <button id="red-attack" class="game-button attack-button w-full h-20 mb-2 px-4">
                        <span class="text-3xl flex-shrink-0">🍁</span>
                        <div class="flex flex-col items-start justify-center flex-grow ml-2">
                            <span class="text-xs">消費E:全て</span>
                            <span class="text-xs">ダメージ: <span id="red-attack-damage"></span></span>
                            <span id="red-energy" class="text-xxs">残E:15</span>
                        </div>
                    </button>
                    <button id="yellow-attack" class="game-button attack-button w-full h-20 mb-2 px-4">
                        <span class="text-3xl flex-shrink-0">🍌</span>
                        <div class="flex flex-col items-start justify-center flex-grow ml-2">
                            <span class="text-xs">消費E:3</span>
                            <span class="text-xs">ダメージ: <span id="yellow-attack-damage"></span></span>
                            <span id="yellow-energy" class="text-xxs">残E:15</span>
                        </div>
                    </button>
                    <button id="blue-attack" class="game-button attack-button w-full h-20 px-4">
                        <span class="text-3xl flex-shrink-0">🧊</span>
                        <div class="flex flex-col items-start justify-center flex-grow ml-2">
                            <span class="text-xs">消費E:2</span>
                            <span class="text-xs">ダメージ: <span id="blue-attack-damage"></span></span>
                            <span id="blue-energy" class="text-xxs">残E:6</span>
                        </div>
                    </button>
                </div>

                <div class="direction-buttons mt-4">
                    <div class="flex flex-col items-center">
                        <button id="move-up" class="game-button w-[34px] h-[34px] text-xl rounded-full">▲</button>
                        <div class="flex">
                            <button id="move-left" class="game-button w-[34px] h-[34px] text-xl rounded-full">◀</button>
                            <div class="w-[34px] h-[34px]"></div>
                            <button id="move-right" class="game-button w-[34px] h-[34px] text-xl rounded-full">▶</button>
                        </div>
                        <button id="move-down" class="game-button w-[34px] h-[34px] text-xl rounded-full">▼</button>
                    </div>
                </div>
            </div>
        </div>
        <button id="reset-button" class="game-button px-6 py-2 mt-8 w-full max-w-[600px]">リセット</button>
    </div>

    <div id="game-over-panel" class="hidden">
        <div class="panel-content">
            <h2 id="game-result-text"></h2>
            <button id="restart-button">もう一度プレイ</button>
        </div>
    </div>

    <script>
        // Canvas and Context
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Game Constants
        const FIELD_SIZE = 25; // 25x25マス
        const VIEW_SIZE = 11;   // 11x11マスが映し出される
        const TILE_SIZE = 34;  // 各マスのサイズ (px)
        const CANVAS_WIDTH = TILE_SIZE * VIEW_SIZE;
        const CANVAS_HEIGHT = TILE_SIZE * VIEW_SIZE;

        canvas.width = CANVAS_WIDTH;
        canvas.height = CANVAS_HEIGHT;

        // Game State Variables
        let player;
        let enemies;
        let boss;
        let field;
        let activeAttackType = null; // 'red', 'yellow', 'blue'
        let damageDisplays = []; // { x, y, amount, color, startTime }
        let isPlayerTurn = true; // プレイヤーのターンかどうか
        let isMoving = false; // 移動中かどうか
        let lastMoveDirection = null; // 最後の移動方向を保持

        // UI Elements
        const moveUpBtn = document.getElementById('move-up');
        const moveDownBtn = document.getElementById('move-down');
        const moveLeftBtn = document.getElementById('move-left');
        const moveRightBtn = document.getElementById('move-right');
        const redAttackBtn = document.getElementById('red-attack');
        const yellowAttackBtn = document.getElementById('yellow-attack');
        const blueAttackBtn = document.getElementById('blue-attack');
        const resetBtn = document.getElementById('reset-button');
        const playerHpValue = document.getElementById('player-hp-value');
        const playerHpBar = document.getElementById('player-hp-bar');
        const bossHpValue = document.getElementById('boss-hp-value');
        const bossHpBar = document.getElementById('boss-hp-bar');
        const redEnergyDisplay = document.getElementById('red-energy');
        const yellowEnergyDisplay = document.getElementById('yellow-energy');
        const blueEnergyDisplay = document.getElementById('blue-energy');
        const gameOverPanel = document.getElementById('game-over-panel');
        const gameResultText = document.getElementById('game-result-text');
        const restartButton = document.getElementById('restart-button');

        // New UI Elements for damage display
        const redAttackDamage = document.getElementById('red-attack-damage');
        const yellowAttackDamage = document.getElementById('yellow-attack-damage');
        const blueAttackDamage = document.getElementById('blue-attack-damage');


        // Player Data
        const PLAYER_MAX_HP = 100;
        const PLAYER_INITIAL_ENERGY = {
            red: 15,
            yellow: 15,
            blue: 6
        };

        // Attack Data
        const ATTACKS = {
            red: {
                name: '🍁',
                target: ['red', 'boss'],
                power: (energy) => energy * 5, // 消費E1につき5
                range: 2, // 半径2マス
                cost: (currentEnergy) => currentEnergy, // 全て消費
                maxEnergy: 15,
                charge: (defeatedEnemies) => 1 + defeatedEnemies // ターン終了時1E回復 + 倒した敵1体につき1E回復
            },
            yellow: {
                name: '🍌',
                target: ['yellow', 'boss'],
                power: 15,
                range: 3, // 半径3マス
                cost: 3,
                maxEnergy: 15,
                charge: (damaged) => 1 + (damaged ? 1 : 0) // ターン終了時1E回復 + ダメージを受けた場合追加で1E回復
            },
            blue: {
                name: '🧊',
                target: ['blue', 'boss'],
                power: (targets) => 5 + targets * 2, // 5 + 攻撃対象1体につき追加で2
                range: 4, // 半径4マス
                cost: 2,
                maxEnergy: 6,
                charge: () => 1 // 移動を行ったターンの終了時に1回復
            }
        };

        // Enemy Data
        const ENEMY_TYPES = {
            red: { hp: 20, detectRange: 1, color: 'red', char: '🔴' }, // 半径1マス
            yellow: { hp: 30, detectRange: 2, color: 'yellow', char: '🟡' }, // 半径2マス
            blue: { hp: 10, detectRange: 3, color: 'blue', char: '🔵' } // 半径3マス
        };

        // Boss Data
        const BOSS_MAX_HP = 200;
        const BOSS_DETECT_RANGE = 3; // 半径3マス
        const BOSS_HEAL_AMOUNT = 5;

        // Utility Functions
        function getDistance(p1, p2) {
            return Math.max(Math.abs(p1.x - p2.x), Math.abs(p1.y - p2.y));
        }

        function isWithinRange(source, target, range) {
            return getDistance(source, target) <= range;
        }

        function getRandomInt(min, max) {
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }

        /**
         * 円と矩形が交差するかどうかを判定します。
         * @param {number} circleX 円の中心のフィールドX座標 (タイル単位)
         * @param {number} circleY 円の中心のフィールドY座標 (タイル単位)
         * @param {number} circleRadiusTiles 円の半径 (タイル単位)
         * @param {number} rectX 矩形の左上隅のフィールドX座標 (タイル単位)
         * @param {number} rectY 矩形の左上隅のフィールドY座標 (タイル単位)
         * @param {number} rectWidthTiles 矩形の幅 (タイル単位)
         * @param {number} rectHeightTiles 矩形の高さ (タイル単位)
         * @returns {boolean} 交差していれば true、そうでなければ false
         */
        function isCircleIntersectingRect(circleX, circleY, circleRadiusTiles, rectX, rectY, rectWidthTiles, rectHeightTiles) {
            // 円と矩形の座標をピクセル単位に変換
            const circlePxX = circleX * TILE_SIZE + TILE_SIZE / 2;
            const circlePxY = circleY * TILE_SIZE + TILE_SIZE / 2;
            const circlePxRadius = (circleRadiusTiles + 0.5) * TILE_SIZE; // drawCircleRangeと同じ半径計算

            const rectPxX = rectX * TILE_SIZE;
            const rectPxY = rectY * TILE_SIZE;
            const rectPxWidth = rectWidthTiles * TILE_SIZE;
            const rectPxHeight = rectHeightTiles * TILE_SIZE;

            // 円の中心から矩形の最も近い点を探索
            let testX = circlePxX;
            let testY = circlePxY;

            if (circlePxX < rectPxX) {
                testX = rectPxX;
            } else if (circlePxX > rectPxX + rectPxWidth) {
                testX = rectPxX + rectPxWidth;
            }

            if (circlePxY < rectPxY) {
                testY = rectPxY;
            } else if (circlePxY > rectPxY + rectPxHeight) {
                testY = rectPxY + rectPxHeight;
            }

            // 最も近い点と円の中心との距離を計算
            const distX = circlePxX - testX;
            const distY = circlePxY - testY;
            const distance = Math.sqrt((distX * distX) + (distY * distY));

            // 距離が半径以下であれば交差している
            return distance <= circlePxRadius;
        }


        // Game Initialization
        function initGame() {
            player = {
                hp: PLAYER_MAX_HP,
                x: Math.floor(FIELD_SIZE / 2),
                y: Math.floor(FIELD_SIZE / 2),
                energy: { ...PLAYER_INITIAL_ENERGY }
            };

            boss = {
                hp: BOSS_MAX_HP,
                x: -1, y: -1, // Will be set randomly
                detectRange: BOSS_DETECT_RANGE,
                maxHp: BOSS_MAX_HP
            };

            enemies = [];
            field = Array(FIELD_SIZE).fill(0).map(() => Array(FIELD_SIZE).fill(0)); // 0: empty, 1: player, 2: enemy, 3: boss

            damageDisplays = [];
            activeAttackType = null; // Reset active attack
            isPlayerTurn = true;
            isMoving = false;
            lastMoveDirection = null;

            // Place player
            field[player.y][player.x] = 1;

            // Place boss randomly, ensuring it's not on player's initial spot
            let bossPlaced = false;
            while (!bossPlaced) {
                const bx = getRandomInt(0, FIELD_SIZE - 1);
                const by = getRandomInt(0, FIELD_SIZE - 1);
                if (field[by][bx] === 0) {
                    boss.x = bx;
                    boss.y = by;
                    field[by][bx] = 3;
                    bossPlaced = true;
                }
            }

            // Place enemies randomly
            const numEnemies = getRandomInt(10, 20);
            for (let i = 0; i < numEnemies; i++) {
                let enemyPlaced = false;
                while (!enemyPlaced) {
                    const ex = getRandomInt(0, FIELD_SIZE - 1);
                    const ey = getRandomInt(0, FIELD_SIZE - 1);
                    if (field[ey][ex] === 0) {
                        const types = Object.keys(ENEMY_TYPES);
                        const randomType = types[getRandomInt(0, types.length - 1)];
                        enemies.push({
                            type: randomType,
                            hp: ENEMY_TYPES[randomType].hp,
                            x: ex,
                            y: ey,
                            detectRange: ENEMY_TYPES[randomType].detectRange,
                            color: ENEMY_TYPES[randomType].color,
                            char: ENEMY_TYPES[randomType].char,
                            maxHp: ENEMY_TYPES[randomType].hp // Store max HP for rendering
                        });
                        field[ey][ex] = 2;
                        enemyPlaced = true;
                    }
                }
            }

            // Hide game over panel
            gameOverPanel.classList.remove('active');
            gameOverPanel.classList.add('hidden');

            updateUI();
            drawGame();
        }

        // Drawing Functions
        function drawGame() {
            ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

            // Calculate view offset to center player
            // Player should be at the center of the view: (VIEW_SIZE / 2 - 0.5) tiles from the top-left of the view
            const startTileX = player.x - (VIEW_SIZE / 2 - 0.5);
            const startTileY = player.y - (VIEW_SIZE / 2 - 0.5);

            // Draw grid
            ctx.strokeStyle = '#4a5568'; // Darker gray for grid lines
            ctx.lineWidth = 1;

            // Calculate the actual range of field tiles to draw
            const drawStartX = Math.floor(startTileX);
            const drawStartY = Math.floor(startTileY);
            const drawEndX = Math.ceil(startTileX + VIEW_SIZE);
            const drawEndY = Math.ceil(startTileY + VIEW_SIZE);

            for (let fieldY = drawStartY; fieldY < drawEndY; fieldY++) {
                for (let fieldX = drawStartX; fieldX < drawEndX; fieldX++) {
                    // Only draw grid lines for actual field tiles (0 to FIELD_SIZE-1)
                    if (fieldX >= 0 && fieldX < FIELD_SIZE && fieldY >= 0 && fieldY < FIELD_SIZE) {
                        const screenX = (fieldX - startTileX) * TILE_SIZE;
                        const screenY = (fieldY - startTileY) * TILE_SIZE;
                        ctx.strokeRect(screenX, screenY, TILE_SIZE, TILE_SIZE);
                    }
                }
            }

            /**
             * 円形の範囲を描画します。
             * @param {number} centerX 円の中心のキャンバスX座標 (px)
             * @param {number} centerY 円の中心のキャンバスY座標 (px)
             * @param {number} rangeInTiles 円の半径 (タイル単位)
             * @param {string} color 描画色 (RGBA)
             */
            function drawCircleRange(centerX, centerY, rangeInTiles, color) {
                // チェビシェフ距離内の全てのタイルを視覚的にカバーするように半径を調整
                const radius = (rangeInTiles + 0.5) * TILE_SIZE;
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                ctx.fillStyle = color;
                ctx.fill();
                ctx.closePath();
            }

            // ボスと敵の索敵範囲を描画
            [boss, ...enemies].forEach(entity => {
                if (!entity || entity.hp <= 0) return;

                // 現在のキャンバスの表示範囲のフィールド座標
                const visibleRectX = startTileX;
                const visibleRectY = startTileY;
                const visibleRectWidth = VIEW_SIZE;
                const visibleRectHeight = VIEW_SIZE;

                // エンティティの索敵範囲が可視領域と交差する場合のみ描画
                if (isCircleIntersectingRect(entity.x, entity.y, entity.detectRange, visibleRectX, visibleRectY, visibleRectWidth, visibleRectHeight)) {
                    const screenX = (entity.x - startTileX) * TILE_SIZE;
                    const screenY = (entity.y - startTileY) * TILE_SIZE;

                    let rangeColor = '';
                    let range = 0;
                    if (entity === boss) {
                        rangeColor = 'rgba(245, 158, 11, 0.1)'; // 薄いオレンジ、半透明 (ボス)
                        range = boss.detectRange;
                    } else { // 敵
                        rangeColor = 'rgba(239, 68, 68, 0.1)'; // 薄い赤、半透明 (敵)
                        range = entity.detectRange;
                    }
                    drawCircleRange(screenX + TILE_SIZE / 2, screenY + TILE_SIZE / 2, range, rangeColor);
                }
            });

            // プレイヤーのアクティブな攻撃範囲を描画
            if (activeAttackType) {
                const attackRange = ATTACKS[activeAttackType].range;
                const visibleRectX = startTileX;
                const visibleRectY = startTileY;
                const visibleRectWidth = VIEW_SIZE;
                const visibleRectHeight = VIEW_SIZE;

                // プレイヤーの攻撃範囲が可視領域と交差する場合のみ描画
                if (isCircleIntersectingRect(player.x, player.y, attackRange, visibleRectX, visibleRectY, visibleRectWidth, visibleRectHeight)) {
                    const screenX = (player.x - startTileX) * TILE_SIZE;
                    const screenY = (player.y - startTileY) * TILE_SIZE;
                    drawCircleRange(screenX + TILE_SIZE / 2, screenY + TILE_SIZE / 2, attackRange, 'rgba(66, 153, 225, 0.2)'); // 薄い青、半透明 (プレイヤー)
                }
            }


            // プレイヤー、敵、ボスを描画 (範囲の上に描画されるように)
            [player, boss, ...enemies].forEach(entity => {
                if (!entity || entity.hp <= 0) return;

                // エンティティが現在のビュー内にいる場合のみ描画
                const screenX = (entity.x - startTileX) * TILE_SIZE;
                const screenY = (entity.y - startTileY) * TILE_SIZE;

                if (screenX >= -TILE_SIZE && screenX < CANVAS_WIDTH + TILE_SIZE &&
                    screenY >= -TILE_SIZE && screenY < CANVAS_HEIGHT + TILE_SIZE) {

                    ctx.font = `${TILE_SIZE * 0.7}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillStyle = '#e2e8f0'; // キャラクターの明るい色

                    let char = '';
                    let hpBarColor = '';
                    let hpBarWidth = 0;
                    let currentHp = 0;
                    let maxHp = 0;

                    if (entity === player) {
                        char = '👤';
                        hpBarColor = '#48bb78'; // プレイヤーHPの緑
                        currentHp = player.hp;
                        maxHp = PLAYER_MAX_HP;
                    } else if (entity === boss) {
                        char = '👹';
                        hpBarColor = '#ef4444'; // ボスHPの赤
                        currentHp = boss.hp;
                        maxHp = BOSS_MAX_HP;
                    } else { // 敵
                        char = entity.char;
                        hpBarColor = '#f59e0b'; // 敵HPのオレンジ
                        currentHp = entity.hp;
                        maxHp = entity.maxHp;
                    }

                    ctx.fillText(char, screenX + TILE_SIZE / 2, screenY + TILE_SIZE / 2 - 10);

                    // エンティティのHPバーを描画
                    ctx.fillStyle = '#4a5568'; // HPバーの背景 (暗い色)
                    ctx.fillRect(screenX + TILE_SIZE * 0.1, screenY + TILE_SIZE * 0.8, TILE_SIZE * 0.8, 5);
                    hpBarWidth = (currentHp / maxHp) * TILE_SIZE * 0.8;
                    ctx.fillStyle = hpBarColor;
                    ctx.fillRect(screenX + TILE_SIZE * 0.1, screenY + TILE_SIZE * 0.8, hpBarWidth, 5);

                    // HP値をHPバーの右下に小さく表示
                    ctx.font = 'bold 10px Arial'; // 小さいフォントサイズ
                    ctx.fillStyle = '#e2e8f0'; // 明るいテキスト色
                    ctx.textAlign = 'right'; // 右寄せ
                    ctx.textBaseline = 'bottom'; // 下揃え
                    ctx.fillText(`${currentHp}`, screenX + TILE_SIZE * 0.9, screenY + TILE_SIZE * 0.8 + 8); // HPバーの右下、少し下に調整
                }
            });

            // ダメージ表示を描画
            const currentTime = performance.now();
            damageDisplays = damageDisplays.filter(d => currentTime - d.startTime < 500); // 0.5秒間表示

            damageDisplays.forEach(d => {
                const screenX = (d.x - startTileX) * TILE_SIZE;
                const screenY = (d.y - startTileY) * TILE_SIZE;

                if (screenX >= -TILE_SIZE && screenX < CANVAS_WIDTH + TILE_SIZE &&
                    screenY >= -TILE_SIZE && screenY < CANVAS_HEIGHT + TILE_SIZE) {
                    ctx.font = 'bold 16px Arial'; // Adjusted font size for damage text
                    ctx.fillStyle = d.color;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'bottom';
                    ctx.fillText(d.amount, screenX + TILE_SIZE / 2, screenY + TILE_SIZE / 2 - 10); /* Adjusted Y position */
                }
            });

            requestAnimationFrame(drawGame);
        }

        function displayDamage(targetX, targetY, amount, color) {
            damageDisplays.push({
                x: targetX,
                y: targetY,
                amount: amount,
                color: color,
                startTime: performance.now()
            });
        }

        // UI Update
        function updateUI() {
            playerHpValue.textContent = player.hp;
            playerHpBar.style.width = `${(player.hp / PLAYER_MAX_HP) * 100}%`;
            playerHpBar.style.backgroundColor = player.hp > PLAYER_MAX_HP / 4 ? '#48bb78' : '#ef4444'; // Green, then red when low

            bossHpValue.textContent = boss.hp;
            bossHpBar.style.width = `${(boss.hp / BOSS_MAX_HP) * 100}%`;
            bossHpBar.style.backgroundColor = boss.hp > BOSS_MAX_HP / 4 ? '#ef4444' : '#f59e0b'; // Red, then orange when low

            redEnergyDisplay.textContent = `残E:${player.energy.red}`;
            yellowEnergyDisplay.textContent = `残E:${player.energy.yellow}`;
            blueEnergyDisplay.textContent = `残E:${player.energy.blue}`;

            // Update damage display for attack buttons
            redAttackDamage.textContent = ATTACKS.red.power(player.energy.red);
            yellowAttackDamage.textContent = ATTACKS.yellow.power;
            blueAttackDamage.textContent = `${ATTACKS.blue.power(0)} (+対象数*2)`; // Base damage + scaling info


            // Disable attack buttons if not enough energy
            redAttackBtn.disabled = player.energy.red === 0;
            yellowAttackBtn.disabled = player.energy.yellow < ATTACKS.yellow.cost;
            blueAttackBtn.disabled = player.energy.blue < ATTACKS.blue.cost;

            // Update active attack button styling
            [redAttackBtn, yellowAttackBtn, blueAttackBtn].forEach(btn => {
                btn.classList.remove('active');
            });
            if (activeAttackType === 'red') redAttackBtn.classList.add('active');
            if (activeAttackType === 'yellow') yellowAttackBtn.classList.add('active');
            if (activeAttackType === 'blue') blueAttackBtn.classList.add('active');

            // Update movement button states
            updateMovementButtons();
        }

        function updateMovementButtons() {
            const canMoveUp = player.y > 0 && field[player.y - 1][player.x] === 0;
            const canMoveDown = player.y < FIELD_SIZE - 1 && field[player.y + 1][player.x] === 0;
            const canMoveLeft = player.x > 0 && field[player.y][player.x - 1] === 0;
            const canMoveRight = player.x < FIELD_SIZE - 1 && field[player.y][player.x + 1] === 0;

            moveUpBtn.disabled = !canMoveUp || !isPlayerTurn || isMoving;
            moveDownBtn.disabled = !canMoveDown || !isPlayerTurn || isMoving;
            moveLeftBtn.disabled = !canMoveLeft || !isPlayerTurn || isMoving;
            moveRightBtn.disabled = !canMoveRight || !isPlayerTurn || isMoving;
        }

        // Game Logic
        async function movePlayer(dx, dy) {
            if (!isPlayerTurn || isMoving) return;

            const newX = player.x + dx;
            const newY = player.y + dy;

            // Check boundaries and obstacles
            if (newX < 0 || newX >= FIELD_SIZE || newY < 0 || newY >= FIELD_SIZE || field[newY][newX] !== 0) {
                console.log("Invalid move: out of bounds or occupied.");
                return;
            }

            isMoving = true;
            updateMovementButtons(); // Disable movement buttons during move

            // Clear old player position
            field[player.y][player.x] = 0;
            player.x = newX;
            player.y = newY;
            field[player.y][player.x] = 1;

            drawGame(); // Redraw immediately after player moves

            console.log(`Player moved to (${player.x}, ${player.y})`);

            await performTurnActions();

            isMoving = false;
            updateMovementButtons(); // Re-enable movement buttons
        }

        async function performTurnActions() {
            let playerDamagedThisTurn = false;
            let enemiesDefeatedThisTurn = 0;

            // 1. プレイヤーの攻撃
            if (activeAttackType) {
                console.log(`Player performing ${activeAttackType} attack.`);
                const attack = ATTACKS[activeAttackType];
                const targets = [];

                // Find enemy targets
                enemies.forEach(enemy => {
                    if (enemy.hp > 0 && isWithinRange(player, enemy, attack.range) && attack.target.includes(enemy.type)) {
                        targets.push(enemy);
                    }
                });

                // Find boss target
                if (boss.hp > 0 && isWithinRange(player, boss, attack.range) && attack.target.includes('boss')) {
                    targets.push(boss);
                }

                if (targets.length > 0) {
                    let damageAmount;
                    if (activeAttackType === 'red') {
                        damageAmount = attack.power(player.energy.red);
                        player.energy.red = 0; // Consume all red energy
                    } else if (activeAttackType === 'yellow') {
                        damageAmount = attack.power;
                        player.energy.yellow = Math.max(0, player.energy.yellow - attack.cost);
                    } else if (activeAttackType === 'blue') {
                        damageAmount = attack.power(targets.length);
                        player.energy.blue = Math.max(0, player.energy.blue - attack.cost);
                    }

                    for (const target of targets) {
                        target.hp = Math.max(0, target.hp - damageAmount);
                        displayDamage(target.x, target.y, damageAmount, '#ef4444'); // Damage text (red)
                        console.log(`${activeAttackType} attack hit ${target === boss ? 'Boss' : target.type} for ${damageAmount} damage. Remaining HP: ${target.hp}`);

                        // Draw line from player to target
                        drawLine(player, target, attack.color);
                        await new Promise(resolve => setTimeout(resolve, 500)); // Show damage for 0.5s
                        clearLine(); // Clear the line

                        if (target.hp <= 0) {
                            if (target === boss) {
                                checkGameEnd();
                                return; // Game ends
                            } else {
                                // Remove defeated enemy from field
                                field[target.y][target.x] = 0;
                                enemiesDefeatedThisTurn++;
                                // 敵を倒すとプレイヤーのHPが30回復
                                player.hp = Math.min(PLAYER_MAX_HP, player.hp + 30);
                                console.log(`敵を倒した！プレイヤーHPが30回復しました。現在HP: ${player.hp}`);
                            }
                        }
                    }
                } else {
                    console.log("No targets in range for player attack.");
                }
            } else {
                console.log("No attack selected by player.");
            }

            // Remove defeated enemies from the array
            enemies = enemies.filter(enemy => enemy.hp > 0);

            // 2. 敵とボスの攻撃
            let totalEnemyDamage = 0;
            const attackingEntities = [];

            // Enemies attack
            enemies.forEach(enemy => {
                if (enemy.hp > 0 && isWithinRange(enemy, player, enemy.detectRange)) {
                    totalEnemyDamage += 5; // Assuming generic enemy attack power of 5
                    attackingEntities.push(enemy);
                    console.log(`${enemy.type} enemy attacks player.`);
                }
            });

            // Boss attacks
            if (boss.hp > 0 && isWithinRange(boss, player, boss.detectRange)) {
                totalEnemyDamage += 10; // Assuming boss attack power of 10
                attackingEntities.push(boss);
                console.log(`Boss attacks player.`);
            }

            if (totalEnemyDamage > 0) {
                player.hp = Math.max(0, player.hp - totalEnemyDamage);
                displayDamage(player.x, player.y, totalEnemyDamage, '#ef4444'); // Damage text (red)
                playerDamagedThisTurn = true;
                console.log(`Player took ${totalEnemyDamage} damage. Remaining HP: ${player.hp}`);

                // Draw lines from attacking entities to player
                for (const attacker of attackingEntities) {
                    drawLine(attacker, player, '#ef4444'); // Enemy/Boss attack lines are red
                }
                await new Promise(resolve => setTimeout(resolve, 500)); // Show damage for 0.5s
                clearLine(); // Clear the lines
            } else {
                console.log("No enemies/boss in range to attack player.");
            }

            // 3. エネルギー回復
            // Red energy
            player.energy.red = Math.min(ATTACKS.red.maxEnergy, player.energy.red + ATTACKS.red.charge(enemiesDefeatedThisTurn));
            // Yellow energy
            player.energy.yellow = Math.min(ATTACKS.yellow.maxEnergy, player.energy.yellow + ATTACKS.yellow.charge(playerDamagedThisTurn));
            // Blue energy (only if player moved this turn)
            if (lastMoveDirection) { // Check if player actually moved
                player.energy.blue = Math.min(ATTACKS.blue.maxEnergy, player.energy.blue + ATTACKS.blue.charge());
            }

            // Boss HP recovery
            if (boss.hp > 0) {
                boss.hp = Math.min(BOSS_MAX_HP, boss.hp + BOSS_HEAL_AMOUNT);
                console.log(`Boss recovered 5 HP. Current HP: ${boss.hp}`);
            }

            lastMoveDirection = null; // Reset last move direction after turn

            checkGameEnd();
            updateUI();
            drawGame();
        }

        function checkGameEnd() {
            if (player.hp <= 0) {
                showGameOverPanel('ゲームオーバー！');
            } else if (boss.hp <= 0) {
                showGameOverPanel('ゲームクリア！');
            }
        }

        function showGameOverPanel(message) {
            gameResultText.textContent = message;
            gameOverPanel.classList.remove('hidden');
            gameOverPanel.classList.add('active');
            // Disable all game buttons
            [moveUpBtn, moveDownBtn, moveLeftBtn, moveRightBtn, redAttackBtn, yellowAttackBtn, blueAttackBtn, resetBtn].forEach(btn => {
                btn.disabled = true;
            });
        }

        function drawLine(p1, p2, color) {
            const viewCenterX = player.x;
            const viewCenterY = player.y;

            const startTileX = player.x - (VIEW_SIZE / 2 - 0.5); // Use the same logic as drawGame for consistent view
            const startTileY = player.y - (VIEW_SIZE / 2 - 0.5); // Use the same logic as drawGame for consistent view

            const screenX1 = (p1.x - startTileX) * TILE_SIZE + TILE_SIZE / 2;
            const screenY1 = (p1.y - startTileY) * TILE_SIZE + TILE_SIZE / 2;
            const screenX2 = (p2.x - startTileX) * TILE_SIZE + TILE_SIZE / 2;
            const screenY2 = (p2.y - startTileY) * TILE_SIZE + TILE_SIZE / 2;

            ctx.beginPath();
            ctx.moveTo(screenX1, screenY1);
            ctx.lineTo(screenX2, screenY2);
            ctx.strokeStyle = color;
            ctx.lineWidth = 3;
            ctx.stroke();
            ctx.closePath();
        }

        function clearLine() {
            // Simply redraw the entire game to clear lines
            drawGame();
        }

        // Event Listeners
        moveUpBtn.addEventListener('click', () => { lastMoveDirection = 'up'; movePlayer(0, -1); });
        moveDownBtn.addEventListener('click', () => { lastMoveDirection = 'down'; movePlayer(0, 1); });
        moveLeftBtn.addEventListener('click', () => { lastMoveDirection = 'left'; movePlayer(-1, 0); });
        moveRightBtn.addEventListener('click', () => { lastMoveDirection = 'right'; movePlayer(1, 0); });

        redAttackBtn.addEventListener('click', () => {
            activeAttackType = activeAttackType === 'red' ? null : 'red';
            updateUI();
        });
        yellowAttackBtn.addEventListener('click', () => {
            activeAttackType = activeAttackType === 'yellow' ? null : 'yellow';
            updateUI();
        });
        blueAttackBtn.addEventListener('click', () => {
            activeAttackType = activeAttackType === 'blue' ? null : 'blue';
            updateUI();
        });

        resetBtn.addEventListener('click', () => {
            initGame();
            // Re-enable all game buttons
            [moveUpBtn, moveDownBtn, moveLeftBtn, moveRightBtn, redAttackBtn, yellowAttackBtn, blueAttackBtn, resetBtn].forEach(btn => {
                btn.disabled = false;
            });
        });

        restartButton.addEventListener('click', () => {
            initGame();
            // Re-enable all game buttons
            [moveUpBtn, moveDownBtn, moveLeftBtn, moveRightBtn, redAttackBtn, yellowAttackBtn, blueAttackBtn, resetBtn].forEach(btn => {
                btn.disabled = false;
            });
        });

        // Initial game setup
        window.onload = initGame;

    </script>
</body>
</html>
