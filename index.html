<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>„Çø„Éº„É≥Âà∂RPG„Ç≤„Éº„É†</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a202c; /* Dark background */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            color: #e2e8f0; /* Light text color */
        }
        #game-container {
            display: flex;
            flex-direction: column;
            background-color: #2d3748; /* Slightly lighter dark background */
            border-radius: 16px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
            padding: 24px;
            gap: 20px;
            max-width: 600px; /* Max width for combined content */
            width: 95%; /* Responsive width */
            box-sizing: border-box;
        }
        #main-content-area { /* New wrapper for left and right sections */
            display: flex;
            flex-direction: row;
            gap: 20px;
            justify-content: center;
            align-items: flex-start;
            flex-wrap: wrap; /* Allow wrapping on smaller screens */
        }
        #left-column { /* New container for canvas and boss HP */
            display: flex;
            flex-direction: column;
            gap: 5px; /* Gap between canvas and boss HP */
            flex-grow: 1; /* Allow left section to grow */
            min-width: 300px; /* Minimum width for canvas */
            max-width: 374px; /* Max width for 11x11 field with TILE_SIZE=34 */
        }
        #canvas-wrapper {
            position: relative;
            border: 2px solid #4a5568; /* Darker gray border */
            border-radius: 8px;
            overflow: hidden;
            background-color: #1a202c; /* Very dark background for field */
            aspect-ratio: 1 / 1; /* Keep aspect ratio */
            display: flex; /* Center canvas content */
            justify-content: center;
            align-items: center;
            width: 100%; /* Take full width of its parent */
        }
        canvas {
            display: block;
            background-color: #1a202c; /* Very dark background for field */
        }
        #right-control-panel { /* Container for player HP, attacks, directions */
            display: flex;
            flex-direction: column;
            gap: 16px;
            align-items: center;
            flex-shrink: 0; /* Prevent shrinking on larger screens */
            width: 200px; /* Fixed width for control panel */
        }
        .direction-buttons, .attack-buttons {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        .direction-buttons {
            align-items: center;
        }
        .direction-buttons div {
            display: flex;
            gap: 8px;
        }
        .game-button {
            background-color: #4299e1; /* Blue */
            color: white;
            padding: 6px 10px;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.1s;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
            border: none;
        }
        .game-button:hover:not(:disabled) {
            background-color: #3182ce; /* Darker blue */
            transform: translateY(-2px);
        }
        .game-button:active:not(:disabled) {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        .game-button:disabled {
            background-color: #4a5568; /* Darker gray for disabled */
            color: #a0aec0; /* Lighter gray text for disabled */
            cursor: not-allowed;
            box-shadow: none;
        }
        .attack-button {
            padding: 8px 12px;
            font-size: 0.9rem;
            display: flex;
            flex-direction: row;
            align-items: center;
            justify-content: space-between;
            text-align: left;
            line-height: 1.2;
        }
        .attack-button.active {
            border: 3px solid #f6e05e; /* Yellow border for active */
            box-shadow: 0 0 15px rgba(246, 224, 94, 0.7);
        }
        #red-attack { background-color: #c53030; } /* Darker Red */
        #red-attack.active { border-color: #f6e05e; }
        #yellow-attack { background-color: #d69e2e; } /* Darker Orange */
        #yellow-attack.active { border-color: #f6e05e; }
        #blue-attack { background-color: #2b6cb0; } /* Darker Blue */
        #blue-attack.active { border-color: #f6e05e; }

        .hp-display, .energy-display {
            font-size: 0.5rem;
            font-weight: bold;
            color: #e2e8f0;
        }
        .hp-bar-container {
            width: 100%;
            background-color: #4a5568;
            border-radius: 4px;
            height: 6px;
            overflow: hidden;
        }
        .hp-bar {
            height: 100%;
            background-color: #ef4444;
            border-radius: 4px;
            transition: width 0.3s ease-out;
        }
        .energy-bar-container {
            width: 100%;
            background-color: #4a5568;
            border-radius: 4px;
            height: 4px;
            overflow: hidden;
            margin-top: 2px;
        }
        .energy-bar {
            height: 100%;
            background-color: #48bb78;
            border-radius: 4px;
            transition: width 0.3s ease-out;
        }

        #reset-button {
            background-color: #9b2c2c;
            margin-top: 20px;
            padding: 10px 20px;
        }
        #reset-button:hover:not(:disabled) {
            background-color: #7b1e1e;
        }

        #game-over-panel {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.85);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            visibility: hidden;
            opacity: 0;
            transition: visibility 0s, opacity 0.3s ease-in-out;
        }
        #game-over-panel.active {
            visibility: visible;
            opacity: 1;
        }
        .panel-content {
            background-color: #2d3748;
            padding: 30px;
            border-radius: 16px;
            text-align: center;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.4);
            transform: scale(0.9);
            transition: transform 0.3s ease-out;
            color: #e2e8f0;
        }
        #game-over-panel.active .panel-content {
            transform: scale(1);
        }
        .panel-content h2 {
            font-size: 2rem;
            margin-bottom: 15px;
            color: #e2e8f0;
        }
        .panel-content button {
            background-color: #4299e1;
            color: white;
            padding: 12px 25px;
            border-radius: 10px;
            font-size: 1rem;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.1s;
            border: none;
        }
        .panel-content button:hover {
            background-color: #3182ce;
            transform: translateY(-2px);
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            #main-content-area {
                flex-direction: column;
                align-items: center;
            }
            #left-column, #right-control-panel {
                width: 100%; /* Full width on smaller screens */
                max-width: 374px; /* Ensure canvas doesn't stretch too wide on small screens */
            }
            .direction-buttons, .attack-buttons {
                flex-direction: row; /* Horizontal on smaller screens */
                flex-wrap: wrap;
                justify-content: center;
            }
            .attack-button {
                flex: 1 1 auto;
                min-width: 80px;
                height: 60px;
            }
            .attack-button span.text-3xl {
                font-size: 2.5rem;
            }
            #game-container {
                padding: 12px;
            }
        }
    </style>
</head>
<body>
    <div id="game-container" class="flex flex-col items-center">
        <h1 class="text-xl font-bold text-gray-300 text-center" style="margin-bottom: 2px;">„Çø„Éº„É≥Âà∂RPG„Ç≤„Éº„É†</h1>

        <div id="main-content-area">
            <div id="left-column">
                <div id="canvas-wrapper">
                    <canvas id="gameCanvas"></canvas>
                </div>

                <div class="boss-hp-panel flex flex-col items-start w-full" style="margin-bottom: 1px;">
                    <span class="hp-display" style="margin-bottom: 2px;">„Éú„ÇπHP: <span id="boss-hp-value"></span></span>
                    <div class="hp-bar-container w-full" style="margin-top: 1px;">
                        <div id="boss-hp-bar" class="hp-bar"></div>
                    </div>
                </div>
            </div>

            <div id="right-control-panel">
                <div class="player-hp-panel flex flex-col items-center w-full" style="margin-bottom: 1px;">
                    <span class="hp-display" style="margin-bottom: 2px;">„Éó„É¨„Ç§„É§„ÉºHP: <span id="player-hp-value"></span></span>
                    <div class="hp-bar-container w-full" style="margin-top: 1px;">
                        <div id="player-hp-bar" class="hp-bar"></div>
                    </div>
                </div>

                <div class="attack-buttons w-full">
                    <button id="red-attack" class="game-button attack-button w-full h-20 mb-2 px-4">
                        <span class="text-3xl flex-shrink-0">üçÅ</span>
                        <div class="flex flex-col items-start justify-center flex-grow ml-2">
                            <span class="text-xs">Ê∂àË≤ªE:ÂÖ®„Å¶</span>
                            <span class="text-xs">„ÉÄ„É°„Éº„Ç∏: <span id="red-attack-damage"></span></span>
                            <span id="red-energy" class="text-xxs">ÊÆãE:15</span>
                        </div>
                    </button>
                    <button id="yellow-attack" class="game-button attack-button w-full h-20 mb-2 px-4">
                        <span class="text-3xl flex-shrink-0">üçå</span>
                        <div class="flex flex-col items-start justify-center flex-grow ml-2">
                            <span class="text-xs">Ê∂àË≤ªE:3</span>
                            <span class="text-xs">„ÉÄ„É°„Éº„Ç∏: <span id="yellow-attack-damage"></span></span>
                            <span id="yellow-energy" class="text-xxs">ÊÆãE:15</span>
                        </div>
                    </button>
                    <button id="blue-attack" class="game-button attack-button w-full h-20 px-4">
                        <span class="text-3xl flex-shrink-0">üßä</span>
                        <div class="flex flex-col items-start justify-center flex-grow ml-2">
                            <span class="text-xs">Ê∂àË≤ªE:2</span>
                            <span class="text-xs">„ÉÄ„É°„Éº„Ç∏: <span id="blue-attack-damage"></span></span>
                            <span id="blue-energy" class="text-xxs">ÊÆãE:6</span>
                        </div>
                    </button>
                </div>

                <div class="direction-buttons mt-4">
                    <div class="flex flex-col items-center">
                        <button id="move-up" class="game-button w-[34px] h-[34px] text-xl rounded-full">‚ñ≤</button>
                        <div class="flex">
                            <button id="move-left" class="game-button w-[34px] h-[34px] text-xl rounded-full">‚óÄ</button>
                            <div class="w-[34px] h-[34px]"></div>
                            <button id="move-right" class="game-button w-[34px] h-[34px] text-xl rounded-full">‚ñ∂</button>
                        </div>
                        <button id="move-down" class="game-button w-[34px] h-[34px] text-xl rounded-full">‚ñº</button>
                    </div>
                </div>
            </div>
        </div>
        <button id="reset-button" class="game-button px-6 py-2 mt-8 w-full max-w-[600px]">„É™„Çª„ÉÉ„Éà</button>
    </div>

    <div id="game-over-panel" class="hidden">
        <div class="panel-content">
            <h2 id="game-result-text"></h2>
            <button id="restart-button">„ÇÇ„ÅÜ‰∏ÄÂ∫¶„Éó„É¨„Ç§</button>
        </div>
    </div>

    <script>
        // Canvas and Context
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Game Constants
        const FIELD_SIZE = 25; // 25x25„Éû„Çπ
        const VIEW_SIZE = 11;   // 11x11„Éû„Çπ„ÅåÊò†„ÅóÂá∫„Åï„Çå„Çã
        const TILE_SIZE = 34;  // ÂêÑ„Éû„Çπ„ÅÆ„Çµ„Ç§„Ç∫ (px)
        const CANVAS_WIDTH = TILE_SIZE * VIEW_SIZE;
        const CANVAS_HEIGHT = TILE_SIZE * VIEW_SIZE;

        canvas.width = CANVAS_WIDTH;
        canvas.height = CANVAS_HEIGHT;

        // Game State Variables
        let player;
        let enemies;
        let boss;
        let field;
        let activeAttackType = null; // 'red', 'yellow', 'blue'
        let damageDisplays = []; // { x, y, amount, color, startTime }
        let isPlayerTurn = true; // „Éó„É¨„Ç§„É§„Éº„ÅÆ„Çø„Éº„É≥„Åã„Å©„ÅÜ„Åã
        let isMoving = false; // ÁßªÂãï‰∏≠„Åã„Å©„ÅÜ„Åã
        let lastMoveDirection = null; // ÊúÄÂæå„ÅÆÁßªÂãïÊñπÂêë„Çí‰øùÊåÅ

        // UI Elements
        const moveUpBtn = document.getElementById('move-up');
        const moveDownBtn = document.getElementById('move-down');
        const moveLeftBtn = document.getElementById('move-left');
        const moveRightBtn = document.getElementById('move-right');
        const redAttackBtn = document.getElementById('red-attack');
        const yellowAttackBtn = document.getElementById('yellow-attack');
        const blueAttackBtn = document.getElementById('blue-attack');
        const resetBtn = document.getElementById('reset-button');
        const playerHpValue = document.getElementById('player-hp-value');
        const playerHpBar = document.getElementById('player-hp-bar');
        const bossHpValue = document.getElementById('boss-hp-value');
        const bossHpBar = document.getElementById('boss-hp-bar');
        const redEnergyDisplay = document.getElementById('red-energy');
        const yellowEnergyDisplay = document.getElementById('yellow-energy');
        const blueEnergyDisplay = document.getElementById('blue-energy');
        const gameOverPanel = document.getElementById('game-over-panel');
        const gameResultText = document.getElementById('game-result-text');
        const restartButton = document.getElementById('restart-button');

        // New UI Elements for damage display
        const redAttackDamage = document.getElementById('red-attack-damage');
        const yellowAttackDamage = document.getElementById('yellow-attack-damage');
        const blueAttackDamage = document.getElementById('blue-attack-damage');


        // Player Data
        const PLAYER_MAX_HP = 100;
        const PLAYER_INITIAL_ENERGY = {
            red: 15,
            yellow: 15,
            blue: 6
        };

        // Attack Data
        const ATTACKS = {
            red: {
                name: 'üçÅ',
                target: ['red', 'boss'],
                power: (energy) => energy * 5, // Ê∂àË≤ªE1„Å´„Å§„Åç5
                range: 2, // ÂçäÂæÑ2„Éû„Çπ
                cost: (currentEnergy) => currentEnergy, // ÂÖ®„Å¶Ê∂àË≤ª
                maxEnergy: 15,
                charge: (defeatedEnemies) => 1 + defeatedEnemies // „Çø„Éº„É≥ÁµÇ‰∫ÜÊôÇ1EÂõûÂæ© + ÂÄí„Åó„ÅüÊïµ1‰Ωì„Å´„Å§„Åç1EÂõûÂæ©
            },
            yellow: {
                name: 'üçå',
                target: ['yellow', 'boss'],
                power: 15,
                range: 3, // ÂçäÂæÑ3„Éû„Çπ
                cost: 3,
                maxEnergy: 15,
                charge: (damaged) => 1 + (damaged ? 1 : 0) // „Çø„Éº„É≥ÁµÇ‰∫ÜÊôÇ1EÂõûÂæ© + „ÉÄ„É°„Éº„Ç∏„ÇíÂèó„Åë„ÅüÂ†¥ÂêàËøΩÂä†„Åß1EÂõûÂæ©
            },
            blue: {
                name: 'üßä',
                target: ['blue', 'boss'],
                power: (targets) => 5 + targets * 2, // 5 + ÊîªÊíÉÂØæË±°1‰Ωì„Å´„Å§„ÅçËøΩÂä†„Åß2
                range: 4, // ÂçäÂæÑ4„Éû„Çπ
                cost: 2,
                maxEnergy: 6,
                charge: () => 1 // ÁßªÂãï„ÇíË°å„Å£„Åü„Çø„Éº„É≥„ÅÆÁµÇ‰∫ÜÊôÇ„Å´1ÂõûÂæ©
            }
        };

        // Enemy Data
        const ENEMY_TYPES = {
            red: { hp: 20, detectRange: 1, color: 'red', char: 'üî¥' }, // ÂçäÂæÑ1„Éû„Çπ
            yellow: { hp: 30, detectRange: 2, color: 'yellow', char: 'üü°' }, // ÂçäÂæÑ2„Éû„Çπ
            blue: { hp: 10, detectRange: 3, color: 'blue', char: 'üîµ' } // ÂçäÂæÑ3„Éû„Çπ
        };

        // Boss Data
        const BOSS_MAX_HP = 200;
        const BOSS_DETECT_RANGE = 3; // ÂçäÂæÑ3„Éû„Çπ
        const BOSS_HEAL_AMOUNT = 5;

        // Utility Functions
        function getDistance(p1, p2) {
            return Math.max(Math.abs(p1.x - p2.x), Math.abs(p1.y - p2.y));
        }

        function isWithinRange(source, target, range) {
            return getDistance(source, target) <= range;
        }

        function getRandomInt(min, max) {
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }

        /**
         * ÂÜÜ„Å®Áü©ÂΩ¢„Åå‰∫§Â∑Æ„Åô„Çã„Åã„Å©„ÅÜ„Åã„ÇíÂà§ÂÆö„Åó„Åæ„Åô„ÄÇ
         * @param {number} circleX ÂÜÜ„ÅÆ‰∏≠ÂøÉ„ÅÆ„Éï„Ç£„Éº„É´„ÉâXÂ∫ßÊ®ô („Çø„Ç§„É´Âçò‰Ωç)
         * @param {number} circleY ÂÜÜ„ÅÆ‰∏≠ÂøÉ„ÅÆ„Éï„Ç£„Éº„É´„ÉâYÂ∫ßÊ®ô („Çø„Ç§„É´Âçò‰Ωç)
         * @param {number} circleRadiusTiles ÂÜÜ„ÅÆÂçäÂæÑ („Çø„Ç§„É´Âçò‰Ωç)
         * @param {number} rectX Áü©ÂΩ¢„ÅÆÂ∑¶‰∏äÈöÖ„ÅÆ„Éï„Ç£„Éº„É´„ÉâXÂ∫ßÊ®ô („Çø„Ç§„É´Âçò‰Ωç)
         * @param {number} rectY Áü©ÂΩ¢„ÅÆÂ∑¶‰∏äÈöÖ„ÅÆ„Éï„Ç£„Éº„É´„ÉâYÂ∫ßÊ®ô („Çø„Ç§„É´Âçò‰Ωç)
         * @param {number} rectWidthTiles Áü©ÂΩ¢„ÅÆÂπÖ („Çø„Ç§„É´Âçò‰Ωç)
         * @param {number} rectHeightTiles Áü©ÂΩ¢„ÅÆÈ´ò„Åï („Çø„Ç§„É´Âçò‰Ωç)
         * @returns {boolean} ‰∫§Â∑Æ„Åó„Å¶„ÅÑ„Çå„Å∞ true„ÄÅ„Åù„ÅÜ„Åß„Å™„Åë„Çå„Å∞ false
         */
        function isCircleIntersectingRect(circleX, circleY, circleRadiusTiles, rectX, rectY, rectWidthTiles, rectHeightTiles) {
            // ÂÜÜ„Å®Áü©ÂΩ¢„ÅÆÂ∫ßÊ®ô„Çí„Éî„ÇØ„Çª„É´Âçò‰Ωç„Å´Â§âÊèõ
            const circlePxX = circleX * TILE_SIZE + TILE_SIZE / 2;
            const circlePxY = circleY * TILE_SIZE + TILE_SIZE / 2;
            const circlePxRadius = (circleRadiusTiles + 0.5) * TILE_SIZE; // drawCircleRange„Å®Âêå„ÅòÂçäÂæÑË®àÁÆó

            const rectPxX = rectX * TILE_SIZE;
            const rectPxY = rectY * TILE_SIZE;
            const rectPxWidth = rectWidthTiles * TILE_SIZE;
            const rectPxHeight = rectHeightTiles * TILE_SIZE;

            // ÂÜÜ„ÅÆ‰∏≠ÂøÉ„Åã„ÇâÁü©ÂΩ¢„ÅÆÊúÄ„ÇÇËøë„ÅÑÁÇπ„ÇíÊé¢Á¥¢
            let testX = circlePxX;
            let testY = circlePxY;

            if (circlePxX < rectPxX) {
                testX = rectPxX;
            } else if (circlePxX > rectPxX + rectPxWidth) {
                testX = rectPxX + rectPxWidth;
            }

            if (circlePxY < rectPxY) {
                testY = rectPxY;
            } else if (circlePxY > rectPxY + rectPxHeight) {
                testY = rectPxY + rectPxHeight;
            }

            // ÊúÄ„ÇÇËøë„ÅÑÁÇπ„Å®ÂÜÜ„ÅÆ‰∏≠ÂøÉ„Å®„ÅÆË∑ùÈõ¢„ÇíË®àÁÆó
            const distX = circlePxX - testX;
            const distY = circlePxY - testY;
            const distance = Math.sqrt((distX * distX) + (distY * distY));

            // Ë∑ùÈõ¢„ÅåÂçäÂæÑ‰ª•‰∏ã„Åß„ÅÇ„Çå„Å∞‰∫§Â∑Æ„Åó„Å¶„ÅÑ„Çã
            return distance <= circlePxRadius;
        }


        // Game Initialization
        function initGame() {
            player = {
                hp: PLAYER_MAX_HP,
                x: Math.floor(FIELD_SIZE / 2),
                y: Math.floor(FIELD_SIZE / 2),
                energy: { ...PLAYER_INITIAL_ENERGY }
            };

            boss = {
                hp: BOSS_MAX_HP,
                x: -1, y: -1, // Will be set randomly
                detectRange: BOSS_DETECT_RANGE,
                maxHp: BOSS_MAX_HP
            };

            enemies = [];
            field = Array(FIELD_SIZE).fill(0).map(() => Array(FIELD_SIZE).fill(0)); // 0: empty, 1: player, 2: enemy, 3: boss

            damageDisplays = [];
            activeAttackType = null; // Reset active attack
            isPlayerTurn = true;
            isMoving = false;
            lastMoveDirection = null;

            // Place player
            field[player.y][player.x] = 1;

            // Place boss randomly, ensuring it's not on player's initial spot
            let bossPlaced = false;
            while (!bossPlaced) {
                const bx = getRandomInt(0, FIELD_SIZE - 1);
                const by = getRandomInt(0, FIELD_SIZE - 1);
                if (field[by][bx] === 0) {
                    boss.x = bx;
                    boss.y = by;
                    field[by][bx] = 3;
                    bossPlaced = true;
                }
            }

            // Place enemies randomly
            const numEnemies = getRandomInt(10, 20);
            for (let i = 0; i < numEnemies; i++) {
                let enemyPlaced = false;
                while (!enemyPlaced) {
                    const ex = getRandomInt(0, FIELD_SIZE - 1);
                    const ey = getRandomInt(0, FIELD_SIZE - 1);
                    if (field[ey][ex] === 0) {
                        const types = Object.keys(ENEMY_TYPES);
                        const randomType = types[getRandomInt(0, types.length - 1)];
                        enemies.push({
                            type: randomType,
                            hp: ENEMY_TYPES[randomType].hp,
                            x: ex,
                            y: ey,
                            detectRange: ENEMY_TYPES[randomType].detectRange,
                            color: ENEMY_TYPES[randomType].color,
                            char: ENEMY_TYPES[randomType].char,
                            maxHp: ENEMY_TYPES[randomType].hp // Store max HP for rendering
                        });
                        field[ey][ex] = 2;
                        enemyPlaced = true;
                    }
                }
            }

            // Hide game over panel
            gameOverPanel.classList.remove('active');
            gameOverPanel.classList.add('hidden');

            updateUI();
            drawGame();
        }

        // Drawing Functions
        function drawGame() {
            ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

            // Calculate view offset to center player
            // Player should be at the center of the view: (VIEW_SIZE / 2 - 0.5) tiles from the top-left of the view
            const startTileX = player.x - (VIEW_SIZE / 2 - 0.5);
            const startTileY = player.y - (VIEW_SIZE / 2 - 0.5);

            // Draw grid
            ctx.strokeStyle = '#4a5568'; // Darker gray for grid lines
            ctx.lineWidth = 1;

            // Calculate the actual range of field tiles to draw
            const drawStartX = Math.floor(startTileX);
            const drawStartY = Math.floor(startTileY);
            const drawEndX = Math.ceil(startTileX + VIEW_SIZE);
            const drawEndY = Math.ceil(startTileY + VIEW_SIZE);

            for (let fieldY = drawStartY; fieldY < drawEndY; fieldY++) {
                for (let fieldX = drawStartX; fieldX < drawEndX; fieldX++) {
                    // Only draw grid lines for actual field tiles (0 to FIELD_SIZE-1)
                    if (fieldX >= 0 && fieldX < FIELD_SIZE && fieldY >= 0 && fieldY < FIELD_SIZE) {
                        const screenX = (fieldX - startTileX) * TILE_SIZE;
                        const screenY = (fieldY - startTileY) * TILE_SIZE;
                        ctx.strokeRect(screenX, screenY, TILE_SIZE, TILE_SIZE);
                    }
                }
            }

            /**
             * ÂÜÜÂΩ¢„ÅÆÁØÑÂõ≤„ÇíÊèèÁîª„Åó„Åæ„Åô„ÄÇ
             * @param {number} centerX ÂÜÜ„ÅÆ‰∏≠ÂøÉ„ÅÆ„Ç≠„É£„É≥„Éê„ÇπXÂ∫ßÊ®ô (px)
             * @param {number} centerY ÂÜÜ„ÅÆ‰∏≠ÂøÉ„ÅÆ„Ç≠„É£„É≥„Éê„ÇπYÂ∫ßÊ®ô (px)
             * @param {number} rangeInTiles ÂÜÜ„ÅÆÂçäÂæÑ („Çø„Ç§„É´Âçò‰Ωç)
             * @param {string} color ÊèèÁîªËâ≤ (RGBA)
             */
            function drawCircleRange(centerX, centerY, rangeInTiles, color) {
                // „ÉÅ„Çß„Éì„Ç∑„Çß„ÉïË∑ùÈõ¢ÂÜÖ„ÅÆÂÖ®„Å¶„ÅÆ„Çø„Ç§„É´„ÇíË¶ñË¶öÁöÑ„Å´„Ç´„Éê„Éº„Åô„Çã„Çà„ÅÜ„Å´ÂçäÂæÑ„ÇíË™øÊï¥
                const radius = (rangeInTiles + 0.5) * TILE_SIZE;
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                ctx.fillStyle = color;
                ctx.fill();
                ctx.closePath();
            }

            // „Éú„Çπ„Å®Êïµ„ÅÆÁ¥¢ÊïµÁØÑÂõ≤„ÇíÊèèÁîª
            [boss, ...enemies].forEach(entity => {
                if (!entity || entity.hp <= 0) return;

                // ÁèæÂú®„ÅÆ„Ç≠„É£„É≥„Éê„Çπ„ÅÆË°®Á§∫ÁØÑÂõ≤„ÅÆ„Éï„Ç£„Éº„É´„ÉâÂ∫ßÊ®ô
                const visibleRectX = startTileX;
                const visibleRectY = startTileY;
                const visibleRectWidth = VIEW_SIZE;
                const visibleRectHeight = VIEW_SIZE;

                // „Ç®„É≥„ÉÜ„Ç£„ÉÜ„Ç£„ÅÆÁ¥¢ÊïµÁØÑÂõ≤„ÅåÂèØË¶ñÈ†òÂüü„Å®‰∫§Â∑Æ„Åô„ÇãÂ†¥Âêà„ÅÆ„ÅøÊèèÁîª
                if (isCircleIntersectingRect(entity.x, entity.y, entity.detectRange, visibleRectX, visibleRectY, visibleRectWidth, visibleRectHeight)) {
                    const screenX = (entity.x - startTileX) * TILE_SIZE;
                    const screenY = (entity.y - startTileY) * TILE_SIZE;

                    let rangeColor = '';
                    let range = 0;
                    if (entity === boss) {
                        rangeColor = 'rgba(245, 158, 11, 0.1)'; // ËñÑ„ÅÑ„Ç™„É¨„É≥„Ç∏„ÄÅÂçäÈÄèÊòé („Éú„Çπ)
                        range = boss.detectRange;
                    } else { // Êïµ
                        rangeColor = 'rgba(239, 68, 68, 0.1)'; // ËñÑ„ÅÑËµ§„ÄÅÂçäÈÄèÊòé (Êïµ)
                        range = entity.detectRange;
                    }
                    drawCircleRange(screenX + TILE_SIZE / 2, screenY + TILE_SIZE / 2, range, rangeColor);
                }
            });

            // „Éó„É¨„Ç§„É§„Éº„ÅÆ„Ç¢„ÇØ„ÉÜ„Ç£„Éñ„Å™ÊîªÊíÉÁØÑÂõ≤„ÇíÊèèÁîª
            if (activeAttackType) {
                const attackRange = ATTACKS[activeAttackType].range;
                const visibleRectX = startTileX;
                const visibleRectY = startTileY;
                const visibleRectWidth = VIEW_SIZE;
                const visibleRectHeight = VIEW_SIZE;

                // „Éó„É¨„Ç§„É§„Éº„ÅÆÊîªÊíÉÁØÑÂõ≤„ÅåÂèØË¶ñÈ†òÂüü„Å®‰∫§Â∑Æ„Åô„ÇãÂ†¥Âêà„ÅÆ„ÅøÊèèÁîª
                if (isCircleIntersectingRect(player.x, player.y, attackRange, visibleRectX, visibleRectY, visibleRectWidth, visibleRectHeight)) {
                    const screenX = (player.x - startTileX) * TILE_SIZE;
                    const screenY = (player.y - startTileY) * TILE_SIZE;
                    drawCircleRange(screenX + TILE_SIZE / 2, screenY + TILE_SIZE / 2, attackRange, 'rgba(66, 153, 225, 0.2)'); // ËñÑ„ÅÑÈùí„ÄÅÂçäÈÄèÊòé („Éó„É¨„Ç§„É§„Éº)
                }
            }


            // „Éó„É¨„Ç§„É§„Éº„ÄÅÊïµ„ÄÅ„Éú„Çπ„ÇíÊèèÁîª (ÁØÑÂõ≤„ÅÆ‰∏ä„Å´ÊèèÁîª„Åï„Çå„Çã„Çà„ÅÜ„Å´)
            [player, boss, ...enemies].forEach(entity => {
                if (!entity || entity.hp <= 0) return;

                // „Ç®„É≥„ÉÜ„Ç£„ÉÜ„Ç£„ÅåÁèæÂú®„ÅÆ„Éì„É•„ÉºÂÜÖ„Å´„ÅÑ„ÇãÂ†¥Âêà„ÅÆ„ÅøÊèèÁîª
                const screenX = (entity.x - startTileX) * TILE_SIZE;
                const screenY = (entity.y - startTileY) * TILE_SIZE;

                if (screenX >= -TILE_SIZE && screenX < CANVAS_WIDTH + TILE_SIZE &&
                    screenY >= -TILE_SIZE && screenY < CANVAS_HEIGHT + TILE_SIZE) {

                    ctx.font = `${TILE_SIZE * 0.7}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillStyle = '#e2e8f0'; // „Ç≠„É£„É©„ÇØ„Çø„Éº„ÅÆÊòé„Çã„ÅÑËâ≤

                    let char = '';
                    let hpBarColor = '';
                    let hpBarWidth = 0;
                    let currentHp = 0;
                    let maxHp = 0;

                    if (entity === player) {
                        char = 'üë§';
                        hpBarColor = '#48bb78'; // „Éó„É¨„Ç§„É§„ÉºHP„ÅÆÁ∑ë
                        currentHp = player.hp;
                        maxHp = PLAYER_MAX_HP;
                    } else if (entity === boss) {
                        char = 'üëπ';
                        hpBarColor = '#ef4444'; // „Éú„ÇπHP„ÅÆËµ§
                        currentHp = boss.hp;
                        maxHp = BOSS_MAX_HP;
                    } else { // Êïµ
                        char = entity.char;
                        hpBarColor = '#f59e0b'; // ÊïµHP„ÅÆ„Ç™„É¨„É≥„Ç∏
                        currentHp = entity.hp;
                        maxHp = entity.maxHp;
                    }

                    ctx.fillText(char, screenX + TILE_SIZE / 2, screenY + TILE_SIZE / 2 - 10);

                    // „Ç®„É≥„ÉÜ„Ç£„ÉÜ„Ç£„ÅÆHP„Éê„Éº„ÇíÊèèÁîª
                    ctx.fillStyle = '#4a5568'; // HP„Éê„Éº„ÅÆËÉåÊôØ (Êöó„ÅÑËâ≤)
                    ctx.fillRect(screenX + TILE_SIZE * 0.1, screenY + TILE_SIZE * 0.8, TILE_SIZE * 0.8, 5);
                    hpBarWidth = (currentHp / maxHp) * TILE_SIZE * 0.8;
                    ctx.fillStyle = hpBarColor;
                    ctx.fillRect(screenX + TILE_SIZE * 0.1, screenY + TILE_SIZE * 0.8, hpBarWidth, 5);

                    // HPÂÄ§„ÇíHP„Éê„Éº„ÅÆÂè≥‰∏ã„Å´Â∞è„Åï„ÅèË°®Á§∫
                    ctx.font = 'bold 10px Arial'; // Â∞è„Åï„ÅÑ„Éï„Ç©„É≥„Éà„Çµ„Ç§„Ç∫
                    ctx.fillStyle = '#e2e8f0'; // Êòé„Çã„ÅÑ„ÉÜ„Ç≠„Çπ„ÉàËâ≤
                    ctx.textAlign = 'right'; // Âè≥ÂØÑ„Åõ
                    ctx.textBaseline = 'bottom'; // ‰∏ãÊèÉ„Åà
                    ctx.fillText(`${currentHp}`, screenX + TILE_SIZE * 0.9, screenY + TILE_SIZE * 0.8 + 8); // HP„Éê„Éº„ÅÆÂè≥‰∏ã„ÄÅÂ∞ë„Åó‰∏ã„Å´Ë™øÊï¥
                }
            });

            // „ÉÄ„É°„Éº„Ç∏Ë°®Á§∫„ÇíÊèèÁîª
            const currentTime = performance.now();
            damageDisplays = damageDisplays.filter(d => currentTime - d.startTime < 500); // 0.5ÁßíÈñìË°®Á§∫

            damageDisplays.forEach(d => {
                const screenX = (d.x - startTileX) * TILE_SIZE;
                const screenY = (d.y - startTileY) * TILE_SIZE;

                if (screenX >= -TILE_SIZE && screenX < CANVAS_WIDTH + TILE_SIZE &&
                    screenY >= -TILE_SIZE && screenY < CANVAS_HEIGHT + TILE_SIZE) {
                    ctx.font = 'bold 16px Arial'; // Adjusted font size for damage text
                    ctx.fillStyle = d.color;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'bottom';
                    ctx.fillText(d.amount, screenX + TILE_SIZE / 2, screenY + TILE_SIZE / 2 - 10); /* Adjusted Y position */
                }
            });

            requestAnimationFrame(drawGame);
        }

        function displayDamage(targetX, targetY, amount, color) {
            damageDisplays.push({
                x: targetX,
                y: targetY,
                amount: amount,
                color: color,
                startTime: performance.now()
            });
        }

        // UI Update
        function updateUI() {
            playerHpValue.textContent = player.hp;
            playerHpBar.style.width = `${(player.hp / PLAYER_MAX_HP) * 100}%`;
            playerHpBar.style.backgroundColor = player.hp > PLAYER_MAX_HP / 4 ? '#48bb78' : '#ef4444'; // Green, then red when low

            bossHpValue.textContent = boss.hp;
            bossHpBar.style.width = `${(boss.hp / BOSS_MAX_HP) * 100}%`;
            bossHpBar.style.backgroundColor = boss.hp > BOSS_MAX_HP / 4 ? '#ef4444' : '#f59e0b'; // Red, then orange when low

            redEnergyDisplay.textContent = `ÊÆãE:${player.energy.red}`;
            yellowEnergyDisplay.textContent = `ÊÆãE:${player.energy.yellow}`;
            blueEnergyDisplay.textContent = `ÊÆãE:${player.energy.blue}`;

            // Update damage display for attack buttons
            redAttackDamage.textContent = ATTACKS.red.power(player.energy.red);
            yellowAttackDamage.textContent = ATTACKS.yellow.power;
            blueAttackDamage.textContent = `${ATTACKS.blue.power(0)} (+ÂØæË±°Êï∞*2)`; // Base damage + scaling info


            // Disable attack buttons if not enough energy
            redAttackBtn.disabled = player.energy.red === 0;
            yellowAttackBtn.disabled = player.energy.yellow < ATTACKS.yellow.cost;
            blueAttackBtn.disabled = player.energy.blue < ATTACKS.blue.cost;

            // Update active attack button styling
            [redAttackBtn, yellowAttackBtn, blueAttackBtn].forEach(btn => {
                btn.classList.remove('active');
            });
            if (activeAttackType === 'red') redAttackBtn.classList.add('active');
            if (activeAttackType === 'yellow') yellowAttackBtn.classList.add('active');
            if (activeAttackType === 'blue') blueAttackBtn.classList.add('active');

            // Update movement button states
            updateMovementButtons();
        }

        function updateMovementButtons() {
            const canMoveUp = player.y > 0 && field[player.y - 1][player.x] === 0;
            const canMoveDown = player.y < FIELD_SIZE - 1 && field[player.y + 1][player.x] === 0;
            const canMoveLeft = player.x > 0 && field[player.y][player.x - 1] === 0;
            const canMoveRight = player.x < FIELD_SIZE - 1 && field[player.y][player.x + 1] === 0;

            moveUpBtn.disabled = !canMoveUp || !isPlayerTurn || isMoving;
            moveDownBtn.disabled = !canMoveDown || !isPlayerTurn || isMoving;
            moveLeftBtn.disabled = !canMoveLeft || !isPlayerTurn || isMoving;
            moveRightBtn.disabled = !canMoveRight || !isPlayerTurn || isMoving;
        }

        // Game Logic
        async function movePlayer(dx, dy) {
            if (!isPlayerTurn || isMoving) return;

            const newX = player.x + dx;
            const newY = player.y + dy;

            // Check boundaries and obstacles
            if (newX < 0 || newX >= FIELD_SIZE || newY < 0 || newY >= FIELD_SIZE || field[newY][newX] !== 0) {
                console.log("Invalid move: out of bounds or occupied.");
                return;
            }

            isMoving = true;
            updateMovementButtons(); // Disable movement buttons during move

            // Clear old player position
            field[player.y][player.x] = 0;
            player.x = newX;
            player.y = newY;
            field[player.y][player.x] = 1;

            drawGame(); // Redraw immediately after player moves

            console.log(`Player moved to (${player.x}, ${player.y})`);

            await performTurnActions();

            isMoving = false;
            updateMovementButtons(); // Re-enable movement buttons
        }

        async function performTurnActions() {
            let playerDamagedThisTurn = false;
            let enemiesDefeatedThisTurn = 0;

            // 1. „Éó„É¨„Ç§„É§„Éº„ÅÆÊîªÊíÉ
            if (activeAttackType) {
                console.log(`Player performing ${activeAttackType} attack.`);
                const attack = ATTACKS[activeAttackType];
                const targets = [];

                // Find enemy targets
                enemies.forEach(enemy => {
                    if (enemy.hp > 0 && isWithinRange(player, enemy, attack.range) && attack.target.includes(enemy.type)) {
                        targets.push(enemy);
                    }
                });

                // Find boss target
                if (boss.hp > 0 && isWithinRange(player, boss, attack.range) && attack.target.includes('boss')) {
                    targets.push(boss);
                }

                if (targets.length > 0) {
                    let damageAmount;
                    if (activeAttackType === 'red') {
                        damageAmount = attack.power(player.energy.red);
                        player.energy.red = 0; // Consume all red energy
                    } else if (activeAttackType === 'yellow') {
                        damageAmount = attack.power;
                        player.energy.yellow = Math.max(0, player.energy.yellow - attack.cost);
                    } else if (activeAttackType === 'blue') {
                        damageAmount = attack.power(targets.length);
                        player.energy.blue = Math.max(0, player.energy.blue - attack.cost);
                    }

                    for (const target of targets) {
                        target.hp = Math.max(0, target.hp - damageAmount);
                        displayDamage(target.x, target.y, damageAmount, '#ef4444'); // Damage text (red)
                        console.log(`${activeAttackType} attack hit ${target === boss ? 'Boss' : target.type} for ${damageAmount} damage. Remaining HP: ${target.hp}`);

                        // Draw line from player to target
                        drawLine(player, target, attack.color);
                        await new Promise(resolve => setTimeout(resolve, 500)); // Show damage for 0.5s
                        clearLine(); // Clear the line

                        if (target.hp <= 0) {
                            if (target === boss) {
                                checkGameEnd();
                                return; // Game ends
                            } else {
                                // Remove defeated enemy from field
                                field[target.y][target.x] = 0;
                                enemiesDefeatedThisTurn++;
                                // Êïµ„ÇíÂÄí„Åô„Å®„Éó„É¨„Ç§„É§„Éº„ÅÆHP„Åå30ÂõûÂæ©
                                player.hp = Math.min(PLAYER_MAX_HP, player.hp + 30);
                                console.log(`Êïµ„ÇíÂÄí„Åó„ÅüÔºÅ„Éó„É¨„Ç§„É§„ÉºHP„Åå30ÂõûÂæ©„Åó„Åæ„Åó„Åü„ÄÇÁèæÂú®HP: ${player.hp}`);
                            }
                        }
                    }
                } else {
                    console.log("No targets in range for player attack.");
                }
            } else {
                console.log("No attack selected by player.");
            }

            // Remove defeated enemies from the array
            enemies = enemies.filter(enemy => enemy.hp > 0);

            // 2. Êïµ„Å®„Éú„Çπ„ÅÆÊîªÊíÉ
            let totalEnemyDamage = 0;
            const attackingEntities = [];

            // Enemies attack
            enemies.forEach(enemy => {
                if (enemy.hp > 0 && isWithinRange(enemy, player, enemy.detectRange)) {
                    totalEnemyDamage += 5; // Assuming generic enemy attack power of 5
                    attackingEntities.push(enemy);
                    console.log(`${enemy.type} enemy attacks player.`);
                }
            });

            // Boss attacks
            if (boss.hp > 0 && isWithinRange(boss, player, boss.detectRange)) {
                totalEnemyDamage += 10; // Assuming boss attack power of 10
                attackingEntities.push(boss);
                console.log(`Boss attacks player.`);
            }

            if (totalEnemyDamage > 0) {
                player.hp = Math.max(0, player.hp - totalEnemyDamage);
                displayDamage(player.x, player.y, totalEnemyDamage, '#ef4444'); // Damage text (red)
                playerDamagedThisTurn = true;
                console.log(`Player took ${totalEnemyDamage} damage. Remaining HP: ${player.hp}`);

                // Draw lines from attacking entities to player
                for (const attacker of attackingEntities) {
                    drawLine(attacker, player, '#ef4444'); // Enemy/Boss attack lines are red
                }
                await new Promise(resolve => setTimeout(resolve, 500)); // Show damage for 0.5s
                clearLine(); // Clear the lines
            } else {
                console.log("No enemies/boss in range to attack player.");
            }

            // 3. „Ç®„Éç„É´„ÇÆ„ÉºÂõûÂæ©
            // Red energy
            player.energy.red = Math.min(ATTACKS.red.maxEnergy, player.energy.red + ATTACKS.red.charge(enemiesDefeatedThisTurn));
            // Yellow energy
            player.energy.yellow = Math.min(ATTACKS.yellow.maxEnergy, player.energy.yellow + ATTACKS.yellow.charge(playerDamagedThisTurn));
            // Blue energy (only if player moved this turn)
            if (lastMoveDirection) { // Check if player actually moved
                player.energy.blue = Math.min(ATTACKS.blue.maxEnergy, player.energy.blue + ATTACKS.blue.charge());
            }

            // Boss HP recovery
            if (boss.hp > 0) {
                boss.hp = Math.min(BOSS_MAX_HP, boss.hp + BOSS_HEAL_AMOUNT);
                console.log(`Boss recovered 5 HP. Current HP: ${boss.hp}`);
            }

            lastMoveDirection = null; // Reset last move direction after turn

            checkGameEnd();
            updateUI();
            drawGame();
        }

        function checkGameEnd() {
            if (player.hp <= 0) {
                showGameOverPanel('„Ç≤„Éº„É†„Ç™„Éº„Éê„ÉºÔºÅ');
            } else if (boss.hp <= 0) {
                showGameOverPanel('„Ç≤„Éº„É†„ÇØ„É™„Ç¢ÔºÅ');
            }
        }

        function showGameOverPanel(message) {
            gameResultText.textContent = message;
            gameOverPanel.classList.remove('hidden');
            gameOverPanel.classList.add('active');
            // Disable all game buttons
            [moveUpBtn, moveDownBtn, moveLeftBtn, moveRightBtn, redAttackBtn, yellowAttackBtn, blueAttackBtn, resetBtn].forEach(btn => {
                btn.disabled = true;
            });
        }

        function drawLine(p1, p2, color) {
            const viewCenterX = player.x;
            const viewCenterY = player.y;

            const startTileX = player.x - (VIEW_SIZE / 2 - 0.5); // Use the same logic as drawGame for consistent view
            const startTileY = player.y - (VIEW_SIZE / 2 - 0.5); // Use the same logic as drawGame for consistent view

            const screenX1 = (p1.x - startTileX) * TILE_SIZE + TILE_SIZE / 2;
            const screenY1 = (p1.y - startTileY) * TILE_SIZE + TILE_SIZE / 2;
            const screenX2 = (p2.x - startTileX) * TILE_SIZE + TILE_SIZE / 2;
            const screenY2 = (p2.y - startTileY) * TILE_SIZE + TILE_SIZE / 2;

            ctx.beginPath();
            ctx.moveTo(screenX1, screenY1);
            ctx.lineTo(screenX2, screenY2);
            ctx.strokeStyle = color;
            ctx.lineWidth = 3;
            ctx.stroke();
            ctx.closePath();
        }

        function clearLine() {
            // Simply redraw the entire game to clear lines
            drawGame();
        }

        // Event Listeners
        moveUpBtn.addEventListener('click', () => { lastMoveDirection = 'up'; movePlayer(0, -1); });
        moveDownBtn.addEventListener('click', () => { lastMoveDirection = 'down'; movePlayer(0, 1); });
        moveLeftBtn.addEventListener('click', () => { lastMoveDirection = 'left'; movePlayer(-1, 0); });
        moveRightBtn.addEventListener('click', () => { lastMoveDirection = 'right'; movePlayer(1, 0); });

        redAttackBtn.addEventListener('click', () => {
            activeAttackType = activeAttackType === 'red' ? null : 'red';
            updateUI();
        });
        yellowAttackBtn.addEventListener('click', () => {
            activeAttackType = activeAttackType === 'yellow' ? null : 'yellow';
            updateUI();
        });
        blueAttackBtn.addEventListener('click', () => {
            activeAttackType = activeAttackType === 'blue' ? null : 'blue';
            updateUI();
        });

        resetBtn.addEventListener('click', () => {
            initGame();
            // Re-enable all game buttons
            [moveUpBtn, moveDownBtn, moveLeftBtn, moveRightBtn, redAttackBtn, yellowAttackBtn, blueAttackBtn, resetBtn].forEach(btn => {
                btn.disabled = false;
            });
        });

        restartButton.addEventListener('click', () => {
            initGame();
            // Re-enable all game buttons
            [moveUpBtn, moveDownBtn, moveLeftBtn, moveRightBtn, redAttackBtn, yellowAttackBtn, blueAttackBtn, resetBtn].forEach(btn => {
                btn.disabled = false;
            });
        });

        // Initial game setup
        window.onload = initGame;

    </script>
</body>
</html>
